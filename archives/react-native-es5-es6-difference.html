<!DOCTYPE html>
<html class="han-la">
  <head>
  <meta charset="utf-8">
  
  <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
  <meta name="renderer" content="webkit">
  <meta name="viewport" content="width=device-width,initial-scale=1,user-scalable=no">
  <meta name="theme-color" content="#16a085">
  
  
  
  <title>React/React Native 的 ES5 ES6 写法对照表 | ことりのおやつにしてやるぞー！</title>

  
  <link rel="icon shortcut" type="image/ico" href="/favicon.ico">
  <link rel="icon" href="/favicon.ico">


  
  
<link rel="stylesheet" href="/css/mori.css">

  
<link rel="stylesheet" href="/css/bootstrap.min.css">

  
<link rel="stylesheet" href="/css/flat-ui.min.css">

  
<link rel="stylesheet" href="/css/prism.css">

  
<link rel="stylesheet" href="/css/nprogress.css">

  
<link rel="stylesheet" href="/fonts/material-design-iconic-font.min.css">


  
  
<meta name="generator" content="Hexo 4.2.0"><link rel="alternate" href="/atom.xml" title="ことりのおやつにしてやるぞー！" type="application/atom+xml">
</head>

<body>
  

  <div id="pjax-container">
    <div id="main" class="container">
  <div id="main-post" role="main" itemscope itemtype="http://schema.org/BlogPosting" style="display:none">
    <article class="post" style="padding-top:20px">
      <h2 itemprop="name headline" style="font-weight:400">React/React Native 的 ES5 ES6 写法对照表</h2>
      <div class="text-right">
        <div class="text-bar">
          <a href="https://kotori.love" class="fui-home"></a>
          
          <a href="#disqus_thread" class="fui-bubble" data-action="comment-go"></a>
          <a style="font-size:30px;margin-left:1px">·</a>
          <a href="https://twitter.com/intent/tweet?url=https://kotori.love/archives/react-native-es5-es6-difference.html" target="_blank" rel="nofollow" data-placement="bottom" data-toggle="tooltip" title="Twitter" class="fui-twitter"></a>
          <a href="https://www.facebook.com/sharer/sharer.php?u=https://kotori.love/archives/react-native-es5-es6-difference.html" target="_blank" rel="nofollow" data-placement="bottom" data-toggle="tooltip" title="Facebook" class="fui-facebook"></a>
          <a href="https://plus.google.com/share?url=https://kotori.love/archives/react-native-es5-es6-difference.html" target="_blank" rel="nofollow" data-placement="bottom" data-toggle="tooltip" title="Google+" class="fui-google-plus"></a>
          <a href="http://service.weibo.com/share/share.php?url=https://kotori.love/archives/react-native-es5-es6-difference.html&title=React/React Native 的 ES5 ES6 写法对照表" target="_blank" rel="nofollow" data-placement="bottom" data-toggle="tooltip" title="Weibo" class="fui-bookmark"></a>
        </div>
        <div class="post-info">
          <span class="post-info-n">
            
              <a href="/categories/%E7%A7%91%E6%8A%80/">科技</a>
            
          </span>
          
            <a href="/tags/react/">react</a>
          
          <a><time datetime="2016-07-13T08:22:00.000Z">2016-07-13</time></a>
        </div>
      </div>
      
      
      <div class="post-content" itemprop="articleBody">
        <h3 id="模块">模块</h3>
<h4 id="引用">引用</h4>
<p>在 ES5 里，如果使用 CommonJS 标准，引入 React 包基本通过 require 进行，代码类似这样：</p>
<pre><code class="language-javascript">//ES5
var React = require(&quot;react&quot;);
var {
    Component,
    PropTypes
} = React;  //引用React抽象组件

var ReactNative = require(&quot;react-native&quot;);
var {
    Image,
    Text,
} = ReactNative;  //引用具体的React Native组件
</code></pre>
<p>在 ES6 里，import 写法更为标准</p>
<pre><code class="language-javascript">//ES6
import React, { 
    Component,
    PropTypes,
} from 'react';
import {
    Image,
    Text
} from 'react-native'
</code></pre>
<p>注意在 React Native 里，import 直到 0.12 + 才能正常运作。</p>
<h4 id="导出单个类">导出单个类</h4>
<p>在 ES5 里，要导出一个类给别的模块用，一般通过 <code>module.exports</code>  来导出</p>
<pre><code class="language-javascript">//ES5
var MyComponent = React.createClass({
    ...
});
module.exports = MyComponent;
</code></pre>
<p>在 ES6 里，通常用 export default 来实现相同的功能：</p>
<pre><code class="language-javascript">//ES6

export default class MyComponent extends Component{
    ...
}
</code></pre>
<p>引用的时候也类似：</p>
<pre><code class="language-javascript">//ES5
var MyComponent = require('./MyComponent');

//ES6
import MyComponent from './MyComponent';
</code></pre>
<h3 id="定义组件">定义组件</h3>
<p>在 ES5 里，通常通过 React.createClass 来定义一个组件类，像这样：</p>
<pre><code class="language-javascript">//ES5
var Photo = React.createClass({
    render: function() {
        return (
            &lt;Image source={this.props.source} /&gt;
        );
    },
});
</code></pre>
<p>在 ES6 里，我们通过定义一个继承自 React.Component 的 class 来定义一个组件类，像这样：</p>
<pre><code class="language-javascript">//ES6
class Photo extends React.Component {
    render() {
        return (
            &lt;Image source={this.props.source} /&gt;
        );
    }
}
</code></pre>
<h4 id="给组件定义方法">给组件定义方法</h4>
<p>从上面的例子里可以看到，给组件定义方法不再用 名字: function () 的写法，而是直接用名字 ()，在方法的最后也不能有逗号了。</p>
<pre><code class="language-javascript">//ES5 
var Photo = React.createClass({
    componentWillMount: function(){

    },
    render: function() {
        return (
            &lt;Image source={this.props.source} /&gt;
        );
    },
});
//ES6
class Photo extends React.Component {
    componentWillMount() {

    }
    render() {
        return (
            &lt;Image source={this.props.source} /&gt;
        );
    }
}
</code></pre>
<h4 id="定义组件的属性类型和默认属性">定义组件的属性类型和默认属性</h4>
<p>在 ES5 里，属性类型和默认属性分别通过 propTypes 成员和 getDefaultProps 方法来实现</p>
<pre><code class="language-javascript">//ES5 
var Video = React.createClass({
    getDefaultProps: function() {
        return {
            autoPlay: false,
            maxLoops: 10,
        };
    },
    propTypes: {
        autoPlay: React.PropTypes.bool.isRequired,
        maxLoops: React.PropTypes.number.isRequired,
        posterFrameSrc: React.PropTypes.string.isRequired,
        videoSrc: React.PropTypes.string.isRequired,
    },
    render: function() {
        return (
            &lt;View /&gt;
        );
    },
});
</code></pre>
<p>在 ES6 里，可以统一使用 static 成员来实现</p>
<pre><code class="language-javascript">//ES6
class Video extends React.Component {
    static defaultProps = {
        autoPlay: false,
        maxLoops: 10,
    };  // 注意这里有分号
    static propTypes = {
        autoPlay: React.PropTypes.bool.isRequired,
        maxLoops: React.PropTypes.number.isRequired,
        posterFrameSrc: React.PropTypes.string.isRequired,
        videoSrc: React.PropTypes.string.isRequired,
    };  // 注意这里有分号
    render() {
        return (
            &lt;View /&gt;
        );
    } // 注意这里既没有分号也没有逗号
}
</code></pre>
<p>也有人这么写，虽然不推荐，但读到代码的时候你应当能明白它的意思：</p>
<pre><code class="language-javascript">//ES6
class Video extends React.Component {
    render() {
        return (
            &lt;View /&gt;
        );
    }
}
Video.defaultProps = {
    autoPlay: false,
    maxLoops: 10,
};
Video.propTypes = {
    autoPlay: React.PropTypes.bool.isRequired,
    maxLoops: React.PropTypes.number.isRequired,
    posterFrameSrc: React.PropTypes.string.isRequired,
    videoSrc: React.PropTypes.string.isRequired,
};
</code></pre>
<p>注意：对 React 开发者而言，static 成员在 IE10 及之前版本不能被继承，而在 IE11 和其它浏览器上可以，这有时候会带来一些问题。React Native 开发者可以不用担心这个问题。</p>
<h3 id="初始化STATE">初始化 STATE</h3>
<p>ES5 下情况类似，</p>
<pre><code class="language-javascript">//ES5 
var Video = React.createClass({
    getInitialState: function() {
        return {
            loopsRemaining: this.props.maxLoops,
        };
    },
})
</code></pre>
<p>ES6 下，有两种写法：</p>
<pre><code class="language-javascript">//ES6
class Video extends React.Component {
    state = {
        loopsRemaining: this.props.maxLoops,
    }
}
</code></pre>
<p>不过我们推荐更易理解的在构造函数中初始化（这样你还可以根据需要做一些计算）：</p>
<pre><code>//ES6
class Video extends React.Component {
    constructor(props){
        super(props);
        this.state = {
            loopsRemaining: this.props.maxLoops,
        };
    }
}
</code></pre>
<h3 id="把方法作为回调提供">把方法作为回调提供</h3>
<p>很多习惯于 ES6 的用户反而不理解在 ES5 下可以这么做：</p>
<pre><code class="language-javascript">//ES5
var PostInfo = React.createClass({
    handleOptionsButtonClick: function(e) {
        // Here, 'this' refers to the component instance.
        this.setState({showOptionsModal: true});
    },
    render: function(){
        return (
            &lt;TouchableHighlight onPress={this.handleOptionsButtonClick}&gt;
                &lt;Text&gt;{this.props.label}&lt;/Text&gt;
            &lt;/TouchableHighlight&gt;
        )
    },
});
</code></pre>
<p>在 ES5 下，React.createClass 会把所有的方法都 bind 一遍，这样可以提交到任意的地方作为回调函数，而 this 不会变化。但官方现在逐步认为这反而是不标准、不易理解的。</p>
<p>在 ES6 下，你需要通过 bind 来绑定 this 引用，或者使用箭头函数（它会绑定当前 scope 的 this 引用）来调用</p>
<pre><code class="language-javascript">//ES6
class PostInfo extends React.Component
{
    handleOptionsButtonClick(e){
        this.setState({showOptionsModal: true});
    }
    render(){
        return (
            &lt;TouchableHighlight 
                onPress={this.handleOptionsButtonClick.bind(this)}
                onPress={e=&gt;this.handleOptionsButtonClick(e)}
                &gt;
                &lt;Text&gt;{this.props.label}&lt;/Text&gt;
            &lt;/TouchableHighlight&gt;
        )
    },
}
</code></pre>
<p>箭头函数实际上是在这里定义了一个临时的函数，箭头函数的箭头 =&gt; 之前是一个空括号、单个的参数名、或用括号括起的多个参数名，而箭头之后可以是一个表达式（作为函数的返回值），或者是用花括号括起的函数体（需要自行通过 return 来返回值，否则返回的是 undefined）。</p>
<pre><code class="language-javascript">// 箭头函数的例子
()=&gt;1
v=&gt;v+1
(a,b)=&gt;a+b
()=&gt;{
    alert(&quot;foo&quot;);
}
e=&gt;{
    if (e == 0){
        return 0;
    }
    return 1000/e;
}
</code></pre>
<p>需要注意的是，不论是 bind 还是箭头函数，每次被执行都返回的是一个新的函数引用，因此如果你还需要函数的引用去做一些别的事情（譬如卸载监听器），那么你必须自己保存这个引用</p>
<pre><code class="language-javascript">// 错误的做法
class PauseMenu extends React.Component{
    componentWillMount(){
        AppStateIOS.addEventListener('change', this.onAppPaused.bind(this));
    }
    componentDidUnmount(){
        AppStateIOS.removeEventListener('change', this.onAppPaused.bind(this));
    }
    onAppPaused(event){
    }
}
// 正确的做法
class PauseMenu extends React.Component{
    constructor(props){
        super(props);
        this._onAppPaused = this.onAppPaused.bind(this);
    }
    componentWillMount(){
        AppStateIOS.addEventListener('change', this._onAppPaused);
    }
    componentDidUnmount(){
        AppStateIOS.removeEventListener('change', this._onAppPaused);
    }
    onAppPaused(event){
    }
}
</code></pre>
<p>从这个帖子中我们还学习到一种新的做法：</p>
<pre><code class="language-javascript">// 正确的做法
class PauseMenu extends React.Component{
    componentWillMount(){
        AppStateIOS.addEventListener('change', this.onAppPaused);
    }
    componentDidUnmount(){
        AppStateIOS.removeEventListener('change', this.onAppPaused);
    }
    onAppPaused = (event) =&gt; {
        //把方法直接作为一个arrow function的属性来定义，初始化的时候就绑定好了this指针
    }
}
</code></pre>
<h3 id="Mixins">Mixins</h3>
<p>在 ES5 下，我们经常使用 mixin 来为我们的类添加一些新的方法，譬如 PureRenderMixin</p>
<pre><code class="language-javascript">var PureRenderMixin = require('react-addons-pure-render-mixin');
React.createClass({
  mixins: [PureRenderMixin],

  render: function() {
    return &lt;div className={this.props.className}&gt;foo&lt;/div&gt;;
  }
});
</code></pre>
<p>然而现在官方已经不再打算在 ES6 里继续推行 Mixin，他们说：Mixins Are Dead. Long Live Composition。</p>
<p>尽管如果要继续使用 mixin，还是有一些第三方的方案可以用，譬如这个方案</p>
<p>不过官方推荐，对于库编写者而言，应当尽快放弃 Mixin 的编写方式，上文中提到 Sebastian Markbåge 的一段代码推荐了一种新的编码方式：</p>
<pre><code class="language-javascript">//Enhance.js
import { Component } from &quot;React&quot;;

export var Enhance = ComposedComponent =&gt; class extends Component {
    constructor() {
        this.state = { data: null };
    }
    componentDidMount() {
        this.setState({ data: 'Hello' });
    }
    render() {
        return &lt;ComposedComponent {...this.props} data={this.state.data} /&gt;;
    }
};
//HigherOrderComponent.js
import { Enhance } from &quot;./Enhance&quot;;

class MyComponent {
    render() {
        if (!this.data) return &lt;div&gt;Waiting...&lt;/div&gt;;
        return &lt;div&gt;{this.data}&lt;/div&gt;;
    }
}

export default Enhance(MyComponent); // Enhanced component
</code></pre>
<p>用一个 “增强函数”，来某个类增加一些方法，并且返回一个新类，这无疑能实现 mixin 所实现的大部分需求。</p>
<h3 id="ES6-带来的其它好处">ES6 + 带来的其它好处</h3>
<h4 id="解构-属性延展">解构 &amp; 属性延展</h4>
<p>结合使用 ES6 + 的解构和属性延展，我们给孩子传递一批属性更为方便了。这个例子把 className 以外的所有属性传递给 div 标签：</p>
<pre><code class="language-javascript">class AutoloadingPostsGrid extends React.Component {
    render() {
        var {
            className,
            ...others,  // contains all properties of this.props except for className
        } = this.props;
        return (
            &lt;div className={className}&gt;
                &lt;PostsGrid {...others} /&gt;
                &lt;button onClick={this.handleLoadMoreClick}&gt;Load more&lt;/button&gt;
            &lt;/div&gt;
        );
    }
}
</code></pre>
<p>下面这种写法，则是传递所有属性的同时，用覆盖新的 className 值：</p>
<pre><code>&lt;div {...this.props} className=&quot;override&quot;&gt;
    …
&lt;/div&gt;
</code></pre>
<p>这个例子则相反，如果属性中没有包含 className，则提供默认的值，而如果属性中已经包含了，则使用属性中的值</p>
<pre><code>&lt;div className=&quot;base&quot; {...this.props}&gt;
    …
&lt;/div&gt;
</code></pre>
<blockquote>
<p>转自 http://bbs.reactnative.cn/topic/15/react-react-native-% E7%9A%84es5-es6% E5%86%99% E6% B3%95% E5% AF% B9% E7%85% A7% E8% A1% A8/2</p>
</blockquote>

      </div>
    </article>
  </div>

  <center>
    <div id="postnav" style="display:none">
      <ul class="pager">
        <li class="previous">
          <a href="https://kotori.love">
            <span class="fui-home"></span>
          </a>
        </li>
        <li class="next" data-action="comment-show">
          <a href="javascript:void(0)">
            <span class="fui-chat"></span>
          </a>
        </li>

        <li class="previous">
          
            <a href="https://kotori.love/archives/react-native-upload.html" title="React Native 中的上传">React Native 中的上传</a>
          
        </li>

        <li class="next">
          
            <a href="https://kotori.love/archives/php-memcached.html" title="初探 memcached">初探 memcached</a>
          
        </li>
      </ul>
    </div>
  </center>

  <div id="disqus_thread" data-title="React/React Native 的 ES5 ES6 写法对照表" data-permalink="https://kotori.love/archives/react-native-es5-es6-difference.html" data-allow-comment=""></div>

  

</div>

  </div>
  <footer id="footer" class="container" style="background:rgba(255,255,255,0);display:none">
  <hr>
  <div style="text-align:center;padding-bottom:9px">
    <p>&copy; 2020 <a href="https://kotori.love">ことりのおやつにしてやるぞー！</a>.
      Using <a target="_blank" href="https://hexo.io/">Hexo</a> & <a target="_blank" href="https://yumoe.com">Moricolor</a>
      / <a href="/atom.xml" data-nopjax>RSS</a>
  </p></div>
</footer>

<script>window.moriVars={bottomTools:{hitokoto:!0,category:!0,tag:!1,search:!0},comment:{use:"disqus",shortname:"sora-diary"},analytics:{use:"google",id:"UA-70944432-1"},url:"https://kotori.love"}</script>


<script src="/js/jquery.min.js"></script>


<script src="/js/bootstrap.js"></script>


<script src="/js/flat-ui.min.js"></script>


<script src="/js/prism.js"></script>


<script src="/js/pjax.js"></script>


<script src="/js/nprogress.js"></script>


<script src="/js/mori.js"></script>



  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-70944432-1"></script>
  <script>function gtag(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","UA-70944432-1")</script>


</body>
</html>
