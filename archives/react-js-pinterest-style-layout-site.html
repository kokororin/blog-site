<!doctype html><html class="han-la"><head><link rel="manifest" href="/manifest.json"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1"><meta name="renderer" content="webkit"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta name="theme-color" content="#16a085"><meta name="description" content="react.js を利用して、創建した挿絵の画像欄"><meta name="keywords" content="react,redux"><title>react.js を利用して、創建した挿絵の画像欄 | あかねぞら</title><link rel="icon shortcut" type="image/ico" href="/favicon.ico"><link rel="icon" href="/favicon.ico"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/kokororin/blog-site@master/assets/app.css?v=d57663896c0ae9f4"><meta name="generator" content="Hexo 4.2.0"><link rel="alternate" href="/atom.xml" title="あかねぞら" type="application/atom+xml"></head><body><div id="pjax-container"><div id="main" class="container"><div id="main-post" role="main" itemscope="" itemtype="http://schema.org/BlogPosting"><article class="post" style="padding-top:20px"><h2 itemprop="name headline" style="font-weight:400">react.js を利用して、創建した挿絵の画像欄</h2><div class="text-right"><div class="text-bar"><a href="/" class="fui-home"></a><a href="#disqus_thread" class="fui-bubble" data-action="comment-go"></a><a style="font-size:30px;margin-left:1px">·</a><a href="https://twitter.com/intent/tweet?url=https://kotori.love/archives/react-js-pinterest-style-layout-site.html" target="_blank" rel="nofollow" data-placement="bottom" data-toggle="tooltip" title="Twitter" class="fui-twitter"></a><a href="https://www.facebook.com/sharer/sharer.php?u=https://kotori.love/archives/react-js-pinterest-style-layout-site.html" target="_blank" rel="nofollow" data-placement="bottom" data-toggle="tooltip" title="Facebook" class="fui-facebook"></a></div><div class="post-info"><span class="post-info-n"><a href="/categories/%E7%A7%91%E6%8A%80/">科技</a></span><a href="/tags/react/">react</a><a href="/tags/redux/">redux</a><a><time datetime="2016-11-25T05:04:00.000Z">2016-11-25</time></a></div></div><div class="post-content" itemprop="articleBody"><p><code>react</code> + <code>redux</code> を使って、Web アプリケーションを組み合わせた。それは <code>pixiv.net</code> の挿絵の画像欄であり、私はそれを <code>pixivの「ラブライブ」発見</code> と呼ばれている。 <code>pixiv.net</code> 挿絵のインターネットにラブライブに関するラブライブ！学園アイドル祭の作品を用いる。ラブライブがそのアプリケーションが好きになると思う。</p><h3 id="特徴">特徴</h3><ul><li>ラベルによって、挿絵を選別する</li><li>挿絵の詳細情報を調べる</li><li>pixiv に登録して、好きな挿絵にブックマークをする</li></ul><h3 id="主な技術">主な技術:</h3><ul><li>react</li><li>react-dom</li><li>react-router-component</li><li>redux</li><li>redux-thunk</li><li>react-redux</li><li>react-mdl</li><li>whatwg-fetch</li><li>webpack</li></ul><h4 id="AJAXリクエスト">AJAX リクエスト</h4><p>AJAX リクエストに関して、たくさんの選択肢がある: <code>fetch</code> 、 <code>superagent</code> 、 <code>axios</code> 、その上 <code>jQuery.ajax</code> 。総合的に比べて、標準的な <code>fetch</code> は必ず最高な選択である。</p><p>fetch の主な長所:</p><ul><li>簡単な文法、更に語義化のようだ</li><li>Promise の標準に基いで、async/await にサポートする。</li><li>便利な同型定理</li></ul><p>原生の支持率は高くない。しかし以下の polyfill を取り入れて、IE8 + にサポートすることができる:</p><ul><li>IE8 は ES3 であるから、ES5 の polyfill を取り入れるのが必要である:<a href="https://github.com/es-shims/es5-shim" target="_blank" rel="noopener">es5-shim, es5-sham</a></li><li>Promise の polyfill を取り入れ: <a href="https://github.com/jakearchibald/es6-promise" target="_blank" rel="noopener">es6-promise</a></li><li>fetch 探測倉を取り入れ:<a href="https://github.com/camsong/fetch-detector" target="_blank" rel="noopener">fetch-detector</a></li><li>fetch の polyfill を取り入れ: <a href="https://github.com/camsong/fetch-ie8" target="_blank" rel="noopener">fetch-ie8</a></li><li>選ばれ：もし jsonp も使えば、<a href="https://github.com/camsong/fetch-jsonp" target="_blank" rel="noopener">fetch-jsonp</a> を取り入れる</li><li>選ばれ：Babel の runtime・モデルを開けて、今、async/await を使っていく</li></ul><p>Fetch polyfill の基本的な原理は window.fetch の方法があるかどうかを測定する。ないなら、XHR を利用して実現する。これも<a href="https://github.com/github/fetch" target="_blank" rel="noopener"> github/fetch</a> の方法であり、しかしあるブラウザー（Chrome45）は元で fetch をサポートする。これらの庫は今、毎日に数千万のリクエストが使用していて、問題ないである！</p><p>fetch のよくある質問</p><ul><li>Fetch リクエストは既定に cookie が無いから、 <code>fetch(url, {credentials: &#x27;include&#x27;})</code> を設置するのが必要である。</li><li>サーバーは <code>400</code> 、 <code>500</code> ミス番号に戻る時、拒絶しない。ネットワーク・ミスのせいで、そのリクエストが完成できない場合、fetch が拒絶される。</li></ul><h4 id="性能合理化">性能合理化</h4><p>このアプリケーションの中に、一つの長いリストがあって、すべての画像のモジュールで onClick 事件を縛って、もしリストの数量は上がってきて、性能の問題も明らかで、ソリューションは主に以下:</p><h5 id="propsの中でbind方法を使えないでください。">props の中で bind 方法を使えないでください。</h5><p><code>onClick</code> 中で <code>bind(this)</code> を操作しないでください。そうすると、毎回 <code>render</code> が新しい関数を形成するから、性能に対する影響は顕著である。同じ、矢じり関数 <code>()=&gt;{}</code> のを使う場合、同じ理論である。それも一回に自動 <code>bind</code> する。良い方案は <code>constructor</code> の中で事前にバンドしたそうである。<a href="https://daveceddia.com/avoid-bind-when-passing-props/" target="_blank" rel="noopener">Don’t Use Bind When Passing Props</a> 。この文章は共に 9 種類のソリューションに言及して、それぞれ利害がある。</p><h5 id="リストに１つの正しいkey属性をあげる">リストに１つの正しい key 属性をあげる</h5><p>周知のように、react 循環中のリストは必ず <code>key</code> 属性を与えなければならなくて、この属性はユーザーが自分で使うのではなくて、React 自分で使ったのです。配列の元素に必ず唯一の <code>key</code> 属性を提供しなければならなくて、私達は直接に配列の <code>index</code> を使って <code>key</code> とする。実はそれが何度も一挙であり、 <code>key</code> を提供しないなら、react は黙認に採用したのが <code>index</code> である。良い方案は<a href="https://www.npmjs.com/package/shortid" target="_blank" rel="noopener"> shortid</a> を使って形成するのである。それは主に<a href="https://medium.com/@robinpokorny/index-as-a-key-is-an-anti-pattern-e0349aece318#.kxj9ttkx4" target="_blank" rel="noopener"> Index as a key is an anti-pattern</a> を参考した。</p><h5 id="setState慎重に用いる">setState 慎重に用いる</h5><p>データを <code>Redux</code> に任せて管理したなら、できるだけ <code>Redux</code> でデータと状態 <code>state</code> を管理してください。少数の情況以外、 <code>shouldComponentUpdate</code> も <code>state</code> の比較が必要なことを忘れないでください。</p><h5 id="Componentが必要なpropsだけを順送りする">Component が必要な props だけを順送りする</h5><p>順送りしたのが多すぎ、あるいは段階が深すぎの場合、 <code>shouldComponentUpdate</code> のデータ比較の負担をもたらして、そして、慎重に用いてください。</p><h5 id="shouldComponentUpdate使用">shouldComponentUpdate 使用</h5><p><code>shouldComponentUpdate</code> は黙認状況で <code>true</code> に戻って、つまり <code>props</code> あるいは state が変化すれば、このモジュールは更新して、そのとおり、 <code>props</code> の変化のように、モジュールも更新する可能性がある。 リストの <code>VirtualDOM</code> は毎回レンダリングする時、新生するから、最も簡単な方法はすべての Item の <code>shouldComponentUpdate</code> を実現することである（現在と取り入れた props を比較するのを通じて、更新するかどうかを判断する。属性は <code>object</code> であるのが、内部の変化を判断するのが必要ので、もし私達は <code>immutable―js</code> が必要である）。</p><h5 id="PureRenderMixin">PureRenderMixin</h5><p>React が提供した <code>PureRenderMixin</code> は、実は以上の必要なことをやってくれて、ファイルの方法に基づいて、十分である。しかし、このプラグインはすべての属性を比較して、いくつか状況で予想するのと違う可能性がある。</p><h5 id="モバイルサイドのロード最適化">モバイルサイドのロード最適化</h5><p>Javascript を <code>localStorage</code> にキャッシュメモリして、バージョンが変動した後、サーバーで新しい js をダウンロードする。ソリューションはモバイル WEB 通用最適化策略紹介からのである。 <code>localStorage</code> は静態の資源をキャッシュメモリして、モバイルサイドと高いバージョンのブラウザーで試み価値があるそうである。ブラウザーを通じて、静的ファイルをキャッシュメモリすることができるけど、いくつか状況で（たとえば f5 の更新）、それども <code>cache―control: max―age=0</code> のリクエストを提出する。リクエストを節約する目的で、静態資源のリクエスト方法を改造することができて、すべての静態資源をひとつのリクエストを通じてロードする。そうすれば、いずれにしても、ページはただ一つのリクエストを出す。もし静的なファイルは更新があれば、サーバーは更新するファイル内容に戻って、js を通じてページの中に挿入して、 <code>localStorage</code> の中でキャッシュメモリをする。もし静的ファイルは更新がないなら、直接に <code>localStorage</code> の中から取り出して、ページの中で挿入して十分である。モバイルサイドにとって、js と css これらの静的ファイルのリクエストをひとつに減らして、やはり効果があるそうである。具体的なものは百度のモバイル版、に参考してください。単のページの運用にとって、 <code>localStorage</code> の貯蓄枠板を使うのも良い選択である。</p><h5 id="インターネット・リクエスト合理化">インターネット・リクエスト合理化</h5><p>Ajax のリクエストもキャッシュメモリして、キャッシュメモリが必要なリクエストは期限が切れ時間のカラムに戻る。データを得た後、期限が切れ時間とデータを <code>localStroage</code> 中で保存して、次回にのリクエストは期限が切れ時間と現在時間に比べて、再度リクエストが必要かどうかを判断する。</p><p>その他、react 各種の問題の集合を進め:<a href="https://github.com/timarney/react-faq" target="_blank" rel="noopener">react-faq</a></p><p>プロジェクト・アドレス:<br><a href="https://pixiv.moe" target="_blank" rel="noopener">https://pixiv.moe</a><br><a href="https://github.com/LoveLiveSunshine/pixiv.moe" target="_blank" rel="noopener">https://github.com/LoveLiveSunshine/pixiv.moe</a></p><p>1 枚の GIF プレビュー図:<br><img src="https://github.com/LoveLiveSunshine/pixiv.moe/blob/master/src/images/intro.gif?raw=true" alt=""></p><p><a href="http://qiita.com/kokororin/items/5c065fb48dcbf61edc6d" target="_blank" rel="noopener">Qiita</a></p></div></article></div><center><div id="postnav"><ul class="pager"><li class="previous"><a href="/"><span class="fui-home"></span></a></li><li class="next" data-action="comment-show"><a href="#"><span class="fui-chat"></span></a></li><li class="previous"><a href="/archives/2016-blog-analytics.html" title="2016 年度博客统计报告">2016 年度博客统计报告</a></li><li class="next"><a href="/archives/curl-login-pixiv.html" title="模拟登录 pixiv.net">模拟登录 pixiv.net</a></li></ul></div></center><div id="valine-comments" style="display:none"></div><div class="post-tor-content"><div class="post-tor" id="postTor"><div class="torarc-t"><div class="torarc-tile"><a href="#main-post"><span class="tori tori-first">- TOC -</span></a><br><a href="#特徴"><span class="tori">特徴</span><br></a><a href="#主な技術"><span class="tori">主な技術:</span><br></a><a href="#AJAXリクエスト"><span class="torii">AJAX リクエスト</span><br></a><a href="#性能合理化"><span class="torii">性能合理化</span><br></a><a href="#propsの中でbind方法を使えないでください。"><span class="toriii">props の中で bind 方法を使えないでください。</span><br></a><a href="#リストに１つの正しいkey属性をあげる"><span class="toriii">リストに１つの正しい key 属性をあげる</span><br></a><a href="#setState慎重に用いる"><span class="toriii">setState 慎重に用いる</span><br></a><a href="#Componentが必要なpropsだけを順送りする"><span class="toriii">Component が必要な props だけを順送りする</span><br></a><a href="#shouldComponentUpdate使用"><span class="toriii">shouldComponentUpdate 使用</span><br></a><a href="#PureRenderMixin"><span class="toriii">PureRenderMixin</span><br></a><a href="#モバイルサイドのロード最適化"><span class="toriii">モバイルサイドのロード最適化</span><br></a><a href="#インターネット・リクエスト合理化"><span class="toriii">インターネット・リクエスト合理化</span><br></a></div></div></div></div></div><footer id="footer" class="container" style="background:rgba(255,255,255,0)"><hr><div style="text-align:center;padding-bottom:9px"><p>© 2014 - 2020 <a href="/">あかねぞら</a>. Using <a target="_blank" href="https://hexo.io/">Hexo</a>  &amp; <a target="_blank" href="https://yumoe.com">Moricolor</a> / <a href="/atom.xml" data-nopjax="true">RSS</a></p></div></footer><script id="mori-json" type="text/json">{"bottomTools":{"hitokoto":true,"category":true,"tag":false,"page":true,"search":true},"style":{"color":{"enabled":false,"colors":["#f48fb1","#f48fb1","#f8bbd0"]}},"comment":{"use":"valine","appId":"ikbNNOUhw2U2KuYFXgcfb9GP-MdYXbMMI","appKey":"ggySdQdQ8EC21u2PXS8iOQNp"},"github":"https://github.com/kokororin","analytics":{"use":"google","id":"UA-70944432-1"},"sentry":{"dsn":"https://7bdda1be9b094ef0b6ff3c364024537c@sentry.io/2406563"}}</script><script src="https://cdn.jsdelivr.net/gh/kokororin/blog-site@master/assets/app.js?v=bdf16e2445312366"></script></div></body></html>